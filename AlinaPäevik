ğŸ“† 10.06 â€“ OTP kontrollleht ja kasutajakogemus
Peamine tegevus vÃµi avastus:
TÃ¤na tegelesin OTP (One-Time Password) sisestamise akna loomisega. EesmÃ¤rk oli, et pÃ¤rast edukat registreerimist ilmuks koodisisestuse aken ainult siis, kui server vastab koodiga 201.

Ã•ppimine:
Sain parema arusaama tingimusliku renderduse loogikast Reactis ning sellest, kuidas jagada vormi loogika mitmeks etapiks. Samuti Ãµppisin API vastustelt sÃµltuvat kasutajateed (flowâ€™d) paremini modelleerima.

JÃ¤reldus:
Kui serverilt saadud olek mÃ¤Ã¤rab kasutajale kuvatava sisu, peab komponentide Ã¼lesehitus olema paindlik ja hÃ¤sti struktureeritud. On oluline selgelt eristada olekud, kus kasutaja ei ole veel registreerunud, on registreerunud, vÃµi on sisseloginud.

Edasine tegevus:
Tulevikus planeerin lisada OTP kinnituse jÃ¤rel suunamise sisselogimislehele ning ka â€œresend OTPâ€ nupu. Kaasates rohkem reaalajas tagasisidet parandab see kasutajakogemust veelgi. 
ğŸ“† 11.06 â€“ â€œMinu ideedâ€ leht ja kasutaja tuvastamine
Peamine tegevus vÃµi avastus:
TÃ¤na tÃ¤iendasin â€œMinu ideedâ€ lehte nii, et see kontrollib esmalt, kas kasutaja on sisse logitud, kasutades /v1/oauth/me API otspunkti. Kui kasutaja on tuvastatud, laaditakse tema ideed kasutades vastavat userId vÃ¤Ã¤rtust.

Ã•ppimine:
Sain vÃ¤ga hea kogemuse, kuidas siduda jÃ¤rjestikuseid API-kutsed kasutaja tuvastamiseks ja isiklike andmete laadimiseks. Oli kasulik kogemus mitme useEffect kasutamisel sÃµltuvuste pÃµhjal.

JÃ¤reldus:
Isiklike andmete kuvamisel on oluline kÃµigepealt kontrollida kasutaja autentimist. Samuti tuleb arvestada olukorraga, kus kasutaja ei ole sisse logitud â€” see vajab eraldi kÃ¤sitlemist (veateade, suunamine jne).

Edasine tegevus:
Kavatsen hiljem lisada ideede loetelule ka lisamise ja muutmise vÃµimaluse ning vÃµib-olla mÃµne filtrifunktsiooni. Samuti vÃµiks mÃµelda rollipÃµhisele ligipÃ¤Ã¤sukontrollile.



ğŸ“† 12. juuni 2025 â€“  Arendus,  API Ã¼hendused, autentimine, CORS
ğŸ“Œ PÃ¤eva sÃ¼ndmus: API pÃ¤ringute parandamine ja turvaliseks muutmine
TÃ¤na keskendusin sellele, et kÃµik meie rakenduse lehed kasutaksid korrektselt API-pÃ¤ringuid ilma CORS-vigadeta ja pÃ¤rast sisselogimist ei tekiks autentimisvigu. Kontrollisin ja parandasid igal lehel Authorization headeri lisamise, kasutasin Bearer ${token} formaati ja veendusin, et kÃµik pÃ¤ringud saadavad ka credentials: 'include'.

Lisaks kirjutasin Ã¼mber kÃµik lehed (nt homepage, myideaspage, newideapage, votingpage), et nad kÃ¤sitleksid vigu ja laadimist loogilisemalt ning kasutajasÃµbralikumalt.

ğŸ” Mida ma avastasin / Ãµppisin (Kolbi mudel):
ğŸ’¡ Kogemus:
API ei tÃ¶Ã¶ta Ãµigesti, kui Authorization-header on valesti vormindatud vÃµi puudu. Ka credentials: 'include' on oluline, kui kasutame cookie-pÃµhist sessiooni.

ğŸ¤” Refleksioon:
Varasemalt olin harjunud lihtsalt fetch()-i kasutama, aga tÃ¤na mÃµistsin, et iga detail (nt headeri Ãµigekiri, tokeni olemasolu kontroll) mÃµjutab sÃ¼steemi tÃ¶Ã¶kindlust vÃ¤ga palju.

ğŸ“š Teooria:
HTTP-autentimine ja CORS-mehhanismid tÃ¶Ã¶tavad koos â€“ kui Ã¼ks komponent on puudu vÃµi valesti seadistatud, vÃµib klient-server suhtlus tÃ¤ielikult ebaÃµnnestuda.

ğŸ›  Rakendamine:
LÃµin authFetch() helper-funktsiooni idee, mis muudaks API-pÃ¤ringute kirjutamise Ã¼htlaseks ja turvaliseks. Edaspidi saame kogu tiimiga seda kasutada.

âœ… KokkuvÃµte:
TÃ¤na tehtud parandused muudavad kogu rakenduse turvalisemaks ja tÃ¶Ã¶kindlamaks. Tunnen, et sain sammu lÃ¤hemale pÃ¤ris arendaja mÃµtteviisile â€“ iga rida koodi peab olema lÃ¤bimÃµeldud ja tÃ¤pne.
